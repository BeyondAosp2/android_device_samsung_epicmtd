#!/stage1/sh
export _PATH="$PATH"
export PATH="/stage1"

mkdir /cache
mkdir /proc
mkdir /sys

date >>/boot.txt
exec >>/boot.txt 2>&1
cd /
mount -t proc proc /proc
mount -t sysfs sysfs /sys

rm /init

bml_over_mtd dump boot 72 reservoir 4012 /stage1/boot.bin

eval $(grep -m 1 -A 1 BOOT_IMAGE_OFFSETS /stage1/boot.bin | tail -n 1)

busybox mount -t yaffs2 /dev/block/mtdblock2 /system
busybox mount -t yaffs2 /dev/block/mtdblock3 /cache

load_offset=$boot_offset
load_len=$boot_len
 
REC_BOOT_ADDR="0x57fff800"
REC_BOOT_MAGIC="0x5EC0B007" # Must be in caps.

if test `devmem "$REC_BOOT_ADDR" 32` = "$REC_BOOT_MAGIC" || grep -q bootmode=2 /proc/cmdline ; then
	# recovery boot
	devmem "$REC_BOOT_ADDR" 32 0x0
	load_offset=$recovery_offset
	load_len=$recovery_len

	# disable lpm
	echo 0 > /sys/class/power_supply/battery/charging_mode_booting
elif ! busybox test -e /system/build.prop ; then
	# emergency boot
        busybox umount /cache
        erase_image cache
        busybox mount -t yaffs2 /dev/block/mtdblock4 /cache
        busybox mkdir /cache/recovery

	busybox mount -t vfat /dev/block/mmcblk0p1 /sdcard	

	UPDATE=$(busybox cat /sdcard/cyanogenmod.cfg)

	if busybox test -e $UPDATE ; then
		busybox echo "install_zip(\"`echo $UPDATE`\");" > /cache/recovery/extendedcommand
  	fi

	load_offset=$recovery_offset
	load_len=$recovery_len

	# disable lpm
	busybox echo 0 > /sys/class/power_supply/battery/charging_mode_booting
fi

dd bs=512 if=/stage1/boot.bin skip=$load_offset count=$load_len | zcat | cpio -i

if grep -q 1 /sys/class/power_supply/battery/charging_mode_booting ; then
	# low power mode
	cp lpm.rc init.rc
fi

busybox umount /cache
busybox umount /system
busybox umount /sdcard
busybox rmdir /sdcard
umount /sys
umount /proc
date >> /boot.txt

rm -rf /stage1 
rm -rf /dev/*

export PATH="${_PATH}"

exec /init
